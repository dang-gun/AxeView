/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/AxeView/AxeDomHelper.ts":
/*!*************************************!*\
  !*** ./src/AxeView/AxeDomHelper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.AxeDomHelper = void 0;\r\n/**\r\n * 이미 완성된 엘리먼트의 처리를 도와주기 위한 헬퍼\r\n * */\r\nclass AxeDomHelper {\r\n    /**\r\n     * 문자열을 변환하는 개체를 생성한다.\r\n     * @param jsonDomHelperOption\r\n     */\r\n    constructor(jsonDomHelperOption) {\r\n        /** 바인딩에 사용할 옵션이 지정되지 않았을때 사용할 기본 옵션 */\r\n        this.DomHelperOptionDefult = {\r\n            OptionUse: false,\r\n            AtagClickEventCancel: false,\r\n            AtagClickEventCallback: null\r\n        };\r\n        /** 바인딩에 사용할 저장된 옵션 */\r\n        this.DomHelperOption = {\r\n            OptionUse: false,\r\n            AtagClickEventCancel: false,\r\n            AtagClickEventCallback: null\r\n        };\r\n        if (undefined === jsonDomHelperOption\r\n            || null === jsonDomHelperOption) { //바인딩 기본 옵션이 들어오지 않았다.\r\n            this.DomHelperOption\r\n                = Object.assign({}, this.DomHelperOptionDefult);\r\n        }\r\n        else {\r\n            //기본 옵션합치기\r\n            this.DomHelperOption\r\n                = Object.assign({}, this.DomHelperOptionDefult, jsonDomHelperOption);\r\n        }\r\n    }\r\n    /**\r\n     * 지정된 돔을 옵션에 따라 처리한다.\r\n     * @param domTarget 처리할 돔\r\n     * @param jsonDomHelperOption 처리 옵션\r\n     */\r\n    DomHelping(domTarget, jsonDomHelperOption) {\r\n        if (undefined === jsonDomHelperOption\r\n            || null === jsonDomHelperOption) {\r\n            //없으면 저장된값 사용\r\n            jsonDomHelperOption = this.DomHelperOption;\r\n        }\r\n        this.DomHelping_ori(domTarget, jsonDomHelperOption);\r\n    }\r\n    /**\r\n     * 바인딩된 데이터를 한번 더 처리한다.\r\n     * @param domTarget\r\n     * @param jsonBindOption\r\n     */\r\n    DomHelping_ori(domTarget, jsonBindOption) {\r\n        let BindOptionTemp = jsonBindOption;\r\n        if (false === BindOptionTemp.OptionUse) { //옵션 사용안함.\r\n            return;\r\n        }\r\n        //A 태그 처리 옵션 ♧♧♧♧♧♧\r\n        domTarget.querySelectorAll(\"a\")\r\n            .forEach((item, key) => {\r\n            let sHrefOnlyTemp = item.getAttribute(\"hrefOnly\");\r\n            if (null === sHrefOnlyTemp) {\r\n                sHrefOnlyTemp = item.getAttribute(\"hrefonly\");\r\n            }\r\n            //무조건 이벤트를 걸어서 옵션처리하는게 가장 편하지만....\r\n            //속도면에서는 필요없을때는 이벤트를 걸지 않는게 맞을듯 하여 이렇게 구현함\r\n            if (\"\" === sHrefOnlyTemp) { //hrefOnly가 빈값이다.\r\n                //hrefOnly가 없으면 null\r\n                //있는데 데이터가 없으면 \"\"\r\n                //속성에 hrefOnly가 있으면 아무런 동작을 하지 않는다.\r\n                //debugger;\r\n            }\r\n            else if (true === BindOptionTemp.AtagClickEventCancel\r\n                && null !== BindOptionTemp.AtagClickEventCallback) { //이벤트는 캔슬\r\n                //콜백 이벤트도 있을때\r\n                item.addEventListener(\"click\", function (event) {\r\n                    event.preventDefault();\r\n                    BindOptionTemp.AtagClickEventCallback(event);\r\n                });\r\n            }\r\n            else if (false === BindOptionTemp.AtagClickEventCancel\r\n                && null !== BindOptionTemp.AtagClickEventCallback) {\r\n                item.addEventListener(\"click\", function (event) {\r\n                    BindOptionTemp.AtagClickEventCallback(event);\r\n                });\r\n            }\r\n            else if (true === BindOptionTemp.AtagClickEventCancel\r\n                && null === BindOptionTemp.AtagClickEventCallback) {\r\n                item.addEventListener(\"click\", function (event) {\r\n                    event.preventDefault();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.AxeDomHelper = AxeDomHelper;\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/AxeDomHelper.ts?");

/***/ }),

/***/ "./src/AxeView/AxeDomHelperOptionInterface.ts":
/*!****************************************************!*\
  !*** ./src/AxeView/AxeDomHelperOptionInterface.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/AxeDomHelperOptionInterface.ts?");

/***/ }),

/***/ "./src/AxeView/AxeView.ts":
/*!********************************!*\
  !*** ./src/AxeView/AxeView.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./OverwatchInterface */ \"./src/AxeView/OverwatchInterface.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./AxeViewDomInterface */ \"./src/AxeView/AxeViewDomInterface.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./OverwatchingType */ \"./src/AxeView/OverwatchingType.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./Overwatch */ \"./src/AxeView/Overwatch.ts\"), exports);\r\nconst AxeDomHelper_1 = __webpack_require__(/*! ./AxeDomHelper */ \"./src/AxeView/AxeDomHelper.ts\");\r\n__exportStar(__webpack_require__(/*! ./AxeDomHelper */ \"./src/AxeView/AxeDomHelper.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./AxeDomHelperOptionInterface */ \"./src/AxeView/AxeDomHelperOptionInterface.ts\"), exports);\r\n/** AxeView 구현 */\r\nclass AxeView {\r\n    constructor(jsonDomHelperOption) {\r\n        /**\r\n         *  이 클래스가 바인딩한 아이템의 개수\r\n         *  고유번호 지정에 사용된다.\r\n         * */\r\n        this.BindCount = 0;\r\n        /**\r\n         * 완성된 돔에 추가처리를 할 헬퍼\r\n         */\r\n        this.AxeDomHelper = null;\r\n        /**\r\n         * html의 주석을 제거할지 여부\r\n         * 능동적으로 찾아서 지우는게 아니라 노드 검색시 주석이 발견되면 지우게 된다.\r\n         * */\r\n        this.CommentDelete = false;\r\n        this.AxeDomHelper = new AxeDomHelper_1.AxeDomHelper(jsonDomHelperOption);\r\n    }\r\n    /**\r\n     * 지정된 HTMLElement의 내용물을 다시 그리고, 타겟 감사자를 찾아 연결한다.\r\n     * ☆ 주의 ☆ 기존 내용물은 모두 제거되고 새로 그려진다.\r\n     * 새로 그리면서 감시자를 연결한다.\r\n     *\r\n     * 기존 내용물을 남기고 부분교체하는 방법을 찾아보았지만 정답이 없어서\r\n     * 그냥 새로그리는 방법을 사용하기로 결정하였다.\r\n     * 단, 텍스트 노드가 없\r\n     *\r\n     * 텍스트 노드가 아닌 대상을 감시할때는\r\n     * @param domParent 검색할 부모 dom\r\n     * @param arrTarget 감시자 리스트\r\n     * @param jsonDomHelperOption 처리 옵션\r\n     */\r\n    BindOverwatch(domParent, arrTarget, jsonDomHelperOption) {\r\n        //html 특성상 내용물의 부분 교체가 불가능하다.(무조건 대상을 싹 새로 고친다.)\r\n        //이 문제 때문에 모니터링이 재대로 안될 수 있다.\r\n        //\r\n        //복잡한 조건을 지킨다면 엘리먼트들을 그대로 두더라도 모니터링이 가능하다.\r\n        //1) 모니터링 할 대상의 앞뒤로 textnode를 분리할 수 있는 엘리먼트(html 태그같은 것들) 들어가고\r\n        //2) 단순 문자열일 때 (html은 안됨)\r\n        //즉, .childNodes 로 봤을때 분리되는 단순 문자열이면 가능하다.\r\n        //\r\n        //처음에는 이런 예외적인 사항을 따로 관리하도록 구현했지만\r\n        //다양한 기능을 추가하면서 이런 예외를 따로 분리해주는 코드가 복잡해지는 문제가 발생하여\r\n        //그냥 모든 개체를 다시 생성하는 방향으로 재구현 하였다.\r\n        //\r\n        //모든 구현이 끝나고 최적화할때 다시 도전해볼 예정이다.\r\n        if (!(domParent)) {\r\n            throw \"검색할 dom 을 전달해야 합니다.\";\r\n        }\r\n        //let objThis: AxeView = this;\r\n        //각 감시자별로 처리해야할 내용\r\n        arrTarget.forEach((item) => {\r\n            ++this.BindCount;\r\n            //고유번호 지정\r\n            item.MyNumber = this.BindCount;\r\n        });\r\n        //새로운 로드를 생성해서 가지고 있을 노드 리스트\r\n        let newParent = [];\r\n        //자식만 추가한다.\r\n        newParent.push(...Array.from(this.NodeMatch_Normal(domParent, arrTarget)\r\n            .childNodes));\r\n        //console.log(\"***** newParent *****\");\r\n        //console.log(newParent);\r\n        //새로 만든 노드를 넣어준다.\r\n        domParent.replaceChildren(...newParent);\r\n        //지정된 돔을 옵션처리 한다.\r\n        this.DomHelper(domParent, jsonDomHelperOption);\r\n    }\r\n    /**\r\n     * 지정된 텍스트 노드에서 감시자와의 매칭 정보를 찾고\r\n     * 새로운 노드를 생성하여 리턴한다.\r\n     * @param nodeText\r\n     * @param owTarget\r\n     * @param refMatch\r\n     * @returns 새로 생성된 ChildNode\r\n     */\r\n    NodeMatch_Text(nodeText, owTarget) {\r\n        let newParent = [];\r\n        //이 텍스트를 잘라서 사용하고 완성된 텍스트 노드\r\n        //이 한 노드에서 여러개의 매칭 데이터가 있을 수 있으므로\r\n        //각자 쪼게서 쓴다음 해당 위치에 쪼겐 데이터를 넣어 완성시켜야 한다.\r\n        //이렇게 안하면 원본 텍스트를 여러번 쓰게 되므로 같은 줄이 여러번 나오는 문제가 있다.\r\n        let arrStrText = [];\r\n        //초기값으로 전달받은 텍스트를 그대로 넣어 준다.\r\n        arrStrText.push({ Text: nodeText.textContent, Overwatch: null, Match: false });\r\n        for (let nOverwatchIdx = 0; nOverwatchIdx < owTarget.length; ++nOverwatchIdx) { //감시자 검색\r\n            let itemOW = owTarget[nOverwatchIdx];\r\n            //console.log(\"arrStrText : \" + itemOW.NameFindString);\r\n            //console.log(arrStrText);\r\n            if (true === itemOW.OverwatchingOneIs\r\n                && true === itemOW.OneDataIs) { //하나만 모니터링 하는 옵션\r\n                //이미 적중한 대상이 있다.\r\n                //다음 검색을 할 필요가 없다.\r\n                continue;\r\n            }\r\n            else {\r\n                //arrStrText에 바로 반영한다.\r\n                this.NodeMatch_String(arrStrText, itemOW);\r\n            }\r\n        } //end for nOverwatchIdx\r\n        //잘라진 데이터를 노드로 변환한다.\r\n        for (let i = 0; i < arrStrText.length; ++i) {\r\n            let itemStrText = arrStrText[i];\r\n            if (null === itemStrText.Overwatch) { //내용물은 있는데 감시자가 없다.\r\n                //일반 택스트라는 소리다.\r\n                //textnode를 생성해서 추가한다.\r\n                newParent.push(document.createTextNode(itemStrText.Text));\r\n            }\r\n            else if (1 /* OverwatchingOutputType.String */ === itemStrText.Overwatch.OverwatchingOutputType\r\n                && 0 /* OverwatchingType.OutputFirst */ === itemStrText.Overwatch.OverwatchingType) { //감시 타입이 단순 문자열 출력이다.\r\n                //일반 택스트라는 소리다.\r\n                //textnode를 생성해서 추가한다.\r\n                newParent.push(document.createTextNode(itemStrText.Overwatch.data));\r\n            }\r\n            else if (1 /* OverwatchingOutputType.String */ === itemStrText.Overwatch.OverwatchingOutputType\r\n                && (1 /* OverwatchingType.Monitoring */ === itemStrText.Overwatch.OverwatchingType\r\n                    || 2 /* OverwatchingType.Monitoring_OneValue */ === itemStrText.Overwatch.OverwatchingType)) { //문자열 모니터링이다.\r\n                if (\"\" === itemStrText.Text) { //내용물이 없다.\r\n                    continue;\r\n                }\r\n                else if (null !== itemStrText.Overwatch) { //매칭된 감시자가 있다.\r\n                    //dom을 만들고\r\n                    let newTextDom = document.createTextNode(itemStrText.Overwatch.data);\r\n                    //부모에 전달\r\n                    newParent.push(newTextDom);\r\n                    //감시자에 추가\r\n                    itemStrText.Overwatch.Dom_Push_Node(newTextDom);\r\n                }\r\n                else { //내용물은 있는데 감시자가 없다.\r\n                    //일반 택스트라는 소리다.\r\n                    //textnode를 생성해서 추가한다.\r\n                    newParent.push(document.createTextNode(itemStrText.Text));\r\n                }\r\n            }\r\n            else if (2 /* OverwatchingOutputType.Html */ === itemStrText.Overwatch.OverwatchingOutputType) { //감시 타입이 html 출력이다.\r\n                if (\"\" === itemStrText.Text) { //내용물이 없다.\r\n                    continue;\r\n                }\r\n                else if (null !== itemStrText.Overwatch) { //매칭된 감시자가 있다.\r\n                    //html 개체를 만들고\r\n                    let newMElem = document.createElement(\"template\");\r\n                    //내용물을 html 처리를 한 후\r\n                    newMElem.insertAdjacentHTML(\"beforeend\", itemStrText.Overwatch.data);\r\n                    //리턴 리스트에 추가\r\n                    newParent.push(newMElem.firstChild);\r\n                    if (1 /* OverwatchingType.Monitoring */ === itemStrText.Overwatch.OverwatchingType\r\n                        || 2 /* OverwatchingType.Monitoring_OneValue */ === itemStrText.Overwatch.OverwatchingType) { //모니터링이다.\r\n                        //감시자  dom리스트에 추가\r\n                        itemStrText.Overwatch.Dom_Push_HTMLElement(newMElem.firstChild);\r\n                    }\r\n                }\r\n                else { //아무조건도 맞지 않는다.\r\n                    //임시로 텍스트 노드로 생성한다.\r\n                    //원칙적으로는 여기에 오면 안된다.\r\n                    newParent.push(document.createTextNode(itemStrText.Text));\r\n                    debugger;\r\n                }\r\n            }\r\n        }\r\n        //console.log(\"▷▷▷ newParent End : \" + nodeText.textContent);\r\n        //console.log(newParent);\r\n        //console.log(\"◁◁ ◁ \");\r\n        return newParent;\r\n    }\r\n    /**\r\n     * 일반 노드(재귀를 한다)\r\n     * 내용물을 분석하여 감시자가 연결된 부모노드(HTMLElement)를 새로 생성한다.\r\n     * 텍스트 노드만 있을때까지 재귀하게 된다.\r\n     * 텍스트 노드는 감시자와 비교하여 잘라내고,\r\n     * 감시자를 연결하고 새로 생성된 HTMLElement을 리턴한다.\r\n     * @param nodeParent\r\n     * @param owTarget\r\n     */\r\n    NodeMatch_Normal(nodeParent, owTarget) {\r\n        //부모노드로 새 엘리먼트를 생성한다.\r\n        //자신의 노드만 생성한다.\r\n        //let newElemParent: HTMLElement = document.createElement(nodeParent.nodeName);\r\n        let newElemParent = nodeParent.cloneNode(false);\r\n        //엘리먼트를 유지하기위해 새로 생성한 부모노드에 엘리먼트를 복사한다.\r\n        //Array.from((nodeParent as HTMLElement).attributes)\r\n        //\t.forEach(attr => { newElemParent.setAttribute(attr.nodeName, attr.nodeValue) });\r\n        //이 노드의 자식 노드 추출\r\n        let arrChildNode = Array.from(nodeParent.childNodes);\r\n        //자식 노드 만큼 검사\r\n        for (let nChildNodeIdx = 0; nChildNodeIdx < arrChildNode.length; ++nChildNodeIdx) {\r\n            //검사할 노드\r\n            let itemNode = arrChildNode[nChildNodeIdx];\r\n            if (Node.TEXT_NODE === itemNode.nodeType) { //텍스트 노드다\r\n                //텍스트 노드를 생성하고\r\n                let newText = this.NodeMatch_Text(itemNode, owTarget);\r\n                //노드에 추가\r\n                for (let nNewTextIdx = 0; nNewTextIdx < newText.length; ++nNewTextIdx) {\r\n                    let itemText = newText[nNewTextIdx];\r\n                    newElemParent.appendChild(itemText);\r\n                }\r\n            }\r\n            else if (Node.COMMENT_NODE === itemNode.nodeType) {\r\n                if (false === this.CommentDelete) {\r\n                    //주석은 그대로 추가한다.(바인딩 안함)\r\n                    newElemParent.appendChild(itemNode);\r\n                }\r\n            }\r\n            else { //일반 노드\r\n                //엘리먼트 검사\r\n                //새 엘리먼트를 매칭 시키고\r\n                let newNodeMatch = this.NodeMatch_Normal(itemNode, owTarget);\r\n                //새 엘리먼트의 어트리뷰트 판단.\r\n                this.NodeMatch_Attr(newNodeMatch, owTarget);\r\n                //새 부모에 추가\r\n                newElemParent.appendChild(newNodeMatch);\r\n            }\r\n        } //end for nChildNodeIdx\r\n        return newElemParent;\r\n    }\r\n    /**\r\n     * 지정된 문자열을 감시자와 비교하여 자르고,\r\n     * 지정된 감시자가 감시할게 있는지 확인하여\r\n     * 잘라진 리스트를 리턴한다.\r\n     * @param sText\r\n     * @param owTarget\r\n     */\r\n    NodeMatch_TextCut(sText, owTarget) {\r\n        let arrStrText = [];\r\n        //검사할 값 임시 저장\r\n        let sTemp = sText;\r\n        let nFindIdx = -1;\r\n        while (true) {\r\n            if (true === owTarget.OverwatchingOneIs\r\n                && true === owTarget.OneDataIs) {\r\n                //이미 하나가 일치했으니 더 검사할 필요가 없다.\r\n                break;\r\n            }\r\n            //뒤에 남은게 있나 검사\r\n            nFindIdx = sTemp.indexOf(owTarget.NameFindString);\r\n            if (0 > nFindIdx) { //일치하는게 하나도 없다.\r\n                break;\r\n            }\r\n            //if (owTarget.NameFindString === \"{{HtmlTest}}\") debugger;\r\n            owTarget.OneDataIs = true;\r\n            if (0 !== nFindIdx) { //검색값이 0이다.\r\n                //검색된값이 맨앞에 있다는 의미이므로 빈값은 추가할 필요가 없다.\r\n                //앞에 값 추가\r\n                arrStrText.push({\r\n                    Text: sTemp.substring(0, nFindIdx),\r\n                    Overwatch: null,\r\n                    Match: false\r\n                });\r\n            }\r\n            //일치값 추가\r\n            arrStrText.push({\r\n                Text: owTarget.NameFindString,\r\n                Overwatch: owTarget,\r\n                Match: true\r\n            });\r\n            //뒤에값은 한번 더 검사해야하니 임시저장\r\n            sTemp = sTemp.substring(nFindIdx + owTarget.NameFindString.length);\r\n            if (\"\" === sTemp) { //뒤에 값이 없다.\r\n                //뒤에 값이 없으면 더 검사할 필요가 없다.\r\n                break;\r\n            }\r\n            //console.log(\"NodeMatch_TextCut(\" + owTarget.NameFindString + \") : \" + sTemp);\r\n        } //end while(true)\r\n        //남은것 추가\r\n        arrStrText.push({\r\n            Text: sTemp,\r\n            Overwatch: null,\r\n            Match: false\r\n        });\r\n        return arrStrText;\r\n    }\r\n    /**\r\n     * 문자열 리스트를 한개의 감시자와 매칭 시키면서 자른다.\r\n     * 한개의 감시자 기준이므로 결과물이 앞에서 뒤로 쌓인다.\r\n     * @param arrStrText 검사 및 변형할 텍스트 배열\r\n     * @param itemOW\r\n     */\r\n    NodeMatch_String(arrStrText, itemOW) {\r\n        //잘려진 문자열중 일치하는 문자열이 있는지 확인한다.\r\n        for (let nFindTextIdx = 0; nFindTextIdx < arrStrText.length; ++nFindTextIdx) {\r\n            let itemFindText = arrStrText[nFindTextIdx];\r\n            //일치하는 문자열 찾기\r\n            let nFindIdx = itemFindText.Text.indexOf(itemOW.NameFindString);\r\n            if (0 <= nFindIdx\r\n                && itemFindText.Match === false) { //있다.\r\n                //이미 매칭된 텍스트는 수정할 필요가 없다.\r\n                //if (itemOW.NameFindString === \"{{HtmlTest}}\") debugger;\r\n                //적중한 대상이 있다.\r\n                //여기서 itemOW.OneDataIs = true;를 넣어버리면\r\n                //텍스트를 쪼겔때 이미 매칭된 결과로 표시되서 쪼게지지 않는다.\r\n                //예> this.NodeMatch_TextCut\r\n                //각 if문 안에서 필요에 따라 변경하자\r\n                let arrStrTextCut = this.NodeMatch_TextCut(itemFindText.Text, itemOW);\r\n                //잘린 대상의 뒤에 추가하고 잘린대상은 지운다.\r\n                arrStrText.splice(nFindTextIdx, 1, ...arrStrTextCut);\r\n            } //end if (0 <= nFindIdx)\r\n        } //end for nFindTextIdx\r\n    }\r\n    /**\r\n     * 어트리뷰트의 내용을 매칭시킨다.\r\n     * 어트리뷰트는 새로 생성하지 안으므로 'nodeParent'를 직접 수정한다.\r\n     * @param nodeParent 이 어트리뷰트가 소속된 개체\r\n     * @param owTarget\r\n     */\r\n    NodeMatch_Attr(nodeParent, owTarget) {\r\n        //어트리뷰트를 추출한다.\r\n        let arrAttr = Array.from(nodeParent.attributes);\r\n        //\r\n        for (let nAttrIdx = 0; nAttrIdx < arrAttr.length; ++nAttrIdx) {\r\n            //검사할 어트리뷰트\r\n            let itemAttr = arrAttr[nAttrIdx];\r\n            this.NodeMatch_AttrOne(itemAttr, owTarget, nodeParent);\r\n        }\r\n    }\r\n    /**\r\n     * 어트리뷰트 한개의 내용을 매칭 시킨다.\r\n     * @param attrItem\r\n     * @param owTarget\r\n     * @param nodeParent  이 어트리뷰트가 소속된 개체\r\n     */\r\n    NodeMatch_AttrOne(attrItem, owTarget, nodeParent) {\r\n        for (let nOverwatchIdx = 0; nOverwatchIdx < owTarget.length; ++nOverwatchIdx) {\r\n            let itemOW = owTarget[nOverwatchIdx];\r\n            if (true === itemOW.OverwatchingOneIs\r\n                && true === itemOW.OneDataIs) { //하나만 모니터링 하는 옵션\r\n                //이미 적중한 대상이 있다.\r\n                //다음 검색을 할 필요가 없다.\r\n                continue;\r\n            }\r\n            else if (2 /* OverwatchingOutputType.Html */ === itemOW.OverwatchingOutputType) { //html 옵션이다.\r\n                //속성에 html은 넣을 수 없으므로 이 옵션은 무시한다.\r\n                continue;\r\n            }\r\n            else if (3 /* OverwatchingOutputType.Function */ === itemOW.OverwatchingOutputType\r\n                || 4 /* OverwatchingOutputType.Function_NameRemoveOn */ === itemOW.OverwatchingOutputType) { //함수\r\n                //함수는 부분교체가 없으므로 무조건 전체 비교다.\r\n                if (attrItem.value === itemOW.NameFindString) { //일치한다.\r\n                    let elemTemp = nodeParent;\r\n                    //속성에 기존 이름 제거\r\n                    elemTemp.removeAttribute(attrItem.name);\r\n                    //감시자에 추가\r\n                    itemOW.OneDataIs = true;\r\n                    if (1 /* OverwatchingType.Monitoring */ === itemOW.OverwatchingType\r\n                        || 2 /* OverwatchingType.Monitoring_OneValue */ === itemOW.OverwatchingType) {\r\n                        itemOW.Dom_Push_Event(nodeParent, attrItem.name, true);\r\n                    }\r\n                    else {\r\n                        //돔에는 추가하지 않는다.\r\n                        itemOW.Dom_Push_Event(nodeParent, attrItem.name, false);\r\n                    }\r\n                }\r\n            }\r\n            else { //문자열과 이외의 상황\r\n                //console.log(\"attrItem : \" + attrItem.name + \", \" + attrItem.value);\r\n                //debugger;\r\n                if (\"value\" === attrItem.name\r\n                    && 3 /* OverwatchingType.Monitoring_AttrValue */ === itemOW.OverwatchingType) { //속성이름이 'value'이고\r\n                    //값을 모니터링 중이다.\r\n                    //값(value)은 다른속성과 다르게 부모의 필드에 바인딩되는 녀석이라\r\n                    //그냥 속성개체를 저장하면 UI에서 입력된 값을 읽을 수 없다.\r\n                    //정확하게는 ui에서 수정하면 읽어지질 않는다...(개체가 달라지나????)\r\n                    //\r\n                    //그래서 이벤트 리스너로 처리하도록 수정하였다.\r\n                    //이 옵션에서는 아래 조건 말고는 동작하지 않는다.\r\n                    if (1 /* OverwatchingOutputType.String */ === itemOW.OverwatchingOutputType) { //출력 방식이 'string'이다.\r\n                        //초기값 입력\r\n                        attrItem.value = itemOW.data;\r\n                        //감시자에 추가\r\n                        itemOW.OneDataIs = true;\r\n                        //감시할 돔 추가\r\n                        //속성의 값(value)만을 모니터링 하는 옵션이다.\r\n                        itemOW.Dom_Push_Attr_ValueMonitoring(nodeParent);\r\n                    }\r\n                }\r\n                else if (\"\" === attrItem.value) { //벨류가 없으면 이름만 있는 속성이다.\r\n                    if (itemOW.NameFindString.toLowerCase() === attrItem.name) { //이름이 감시자와 일치한다.\r\n                        if (5 /* OverwatchingOutputType.Dom */ === itemOW.OverwatchingOutputType) { //돔 개체\r\n                            //소속된 개체를 저장한다.\r\n                            let elemTemp = nodeParent;\r\n                            //기존 이름 제거\r\n                            elemTemp.removeAttribute(attrItem.name);\r\n                            //돔방식은 개체를 리턴해주므로 별도의 모니터링을 하지 않는다.\r\n                            itemOW.Dom_Push_Dom(elemTemp);\r\n                        }\r\n                        else { //일반적인 이름\r\n                            //감시자의 값으로 변경\r\n                            let elemTemp = nodeParent;\r\n                            //기존 이름 제거\r\n                            elemTemp.removeAttribute(attrItem.name);\r\n                            //새 이름 추가(값없음)\r\n                            elemTemp.setAttribute(itemOW.data, \"\");\r\n                            //감시자에 추가\r\n                            itemOW.OneDataIs = true;\r\n                            if (1 /* OverwatchingType.Monitoring */ === itemOW.OverwatchingType\r\n                                || 2 /* OverwatchingType.Monitoring_OneValue */ === itemOW.OverwatchingType) { //모니터링이다.\r\n                                //감시할 돔 추가\r\n                                itemOW.Dom_Push_Valueless(nodeParent);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else if (attrItem.value === itemOW.NameFindString) { //벨류가 하나만 있고, 이것이 일치 한다.\r\n                    //초기값 입력\r\n                    attrItem.value = itemOW.data;\r\n                    //감시자에 추가\r\n                    itemOW.OneDataIs = true;\r\n                    if (1 /* OverwatchingType.Monitoring */ === itemOW.OverwatchingType) { //모니터링이다.\r\n                        //감시할 돔 추가\r\n                        itemOW.Dom_Push_ReplaceValue(attrItem);\r\n                    }\r\n                    else if (2 /* OverwatchingType.Monitoring_OneValue */ === itemOW.OverwatchingType) { //하나의 값만 사용하는경우\r\n                        //감시할 돔 추가\r\n                        itemOW.Dom_Push_OneValue(attrItem);\r\n                    }\r\n                }\r\n                else if (true === attrItem.value.includes(itemOW.NameFindString)) { //값에 부분 일치가 있다.\r\n                    if (true === itemOW.OverwatchingOneIs) { //하나만 교체\r\n                        attrItem.value\r\n                            = attrItem.value.replace(itemOW.NameFindString, itemOW.data);\r\n                    }\r\n                    else { //전체 교체\r\n                        attrItem.value = this.ReplaceAll(attrItem.value, itemOW.NameFindString, itemOW.data);\r\n                    }\r\n                    //감시자에 추가\r\n                    itemOW.OneDataIs = true;\r\n                    if (1 /* OverwatchingType.Monitoring */ === itemOW.OverwatchingType\r\n                        || 2 /* OverwatchingType.Monitoring_OneValue */ === itemOW.OverwatchingType) { //모니터링 이다.\r\n                        //돔추가\r\n                        itemOW.Dom_Push_ReplaceValue(attrItem);\r\n                    }\r\n                }\r\n            } //end if (true === itemOW.OverwatchingOneIs\r\n        } //end for nOverwatchIdx\r\n    }\r\n    /**\r\n     * 지정된 엘리먼트에 비어있지 않은 textnode가 한개라도 있는지 확인한다.\r\n     * 한개라도 있으면 true\r\n     * @param el\r\n     */\r\n    TextNodesIs(el) {\r\n        // https://stackoverflow.com/a/44516001/6725889\r\n        let bReturn = false;\r\n        const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);\r\n        while (walker.nextNode()) {\r\n            let sTemp = walker.currentNode.textContent;\r\n            //직접 정규식을 써야 제거가 되서 'ReplaceAll'를 쓰지 않음\r\n            sTemp = sTemp.replace(/\\n/g, \"\");\r\n            sTemp = sTemp.replace(/\\t/g, \"\");\r\n            if (\"\" !== sTemp) { //하나라도 텍스트 노드 데이터가 있으면\r\n                bReturn = true;\r\n                break;\r\n            }\r\n            ;\r\n        }\r\n        return bReturn;\r\n    }\r\n    /**\r\n     * 지정한 문자열을 모두 찾아\r\n     * @param sOriData 원본\r\n     * @param sSearch 찾을 문자열\r\n     * @param sReplacement 바꿀 문자열\r\n     * @returns 완성된 결과\r\n     */\r\n    ReplaceAll(sOriData, sSearch, sReplacement) {\r\n        return sOriData.replace(new RegExp(sSearch, 'g'), sReplacement);\r\n    }\r\n    /**\r\n     * 지정된 돔을 옵션에 따라 처리한다.\r\n     * @param domTarget 처리할 돔\r\n     * @param jsonDomHelperOption 처리 옵션\r\n     */\r\n    DomHelper(domTarget, jsonDomHelperOption) {\r\n        if (undefined === jsonDomHelperOption\r\n            || null === jsonDomHelperOption\r\n            || false === jsonDomHelperOption.OptionUse) {\r\n            //돔 처리\r\n            this.AxeDomHelper.DomHelping(domTarget, jsonDomHelperOption);\r\n        }\r\n    }\r\n}\r\nexports[\"default\"] = AxeView;\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/AxeView.ts?");

/***/ }),

/***/ "./src/AxeView/AxeViewDomInterface.ts":
/*!********************************************!*\
  !*** ./src/AxeView/AxeViewDomInterface.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/AxeViewDomInterface.ts?");

/***/ }),

/***/ "./src/AxeView/Overwatch.ts":
/*!**********************************!*\
  !*** ./src/AxeView/Overwatch.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Overwatch = void 0;\r\n/** 감시 대상  */\r\nclass Overwatch {\r\n    ;\r\n    /** 연결된 돔 */\r\n    get Dom() {\r\n        return this._Dom;\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - Element\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_Element(domPushData) {\r\n        this.Dom_Push_HTMLElement(domPushData);\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - HTMLElement\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_HTMLElement(domPushData) {\r\n        this._Dom.push({\r\n            AxeViewDomType: 2 /* AxeViewDomType.HTMLElement */,\r\n            Dom: domPushData,\r\n            EventName: null\r\n        });\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - Node\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_Node(domPushData) {\r\n        this._Dom.push({\r\n            AxeViewDomType: 3 /* AxeViewDomType.Node */,\r\n            Dom: domPushData,\r\n            EventName: null\r\n        });\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - Node\r\n     * 돔 개체 형식의 경우 부모는 무조건 하나이고,\r\n     * Set 동작은 하지 안으므로 DataNow에 개체를 넣고 배열에는 추가하지 않는다.\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_Dom(domPushData) {\r\n        this.DataNow = domPushData;\r\n        this.DomIs = true;\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - 값없는 속성\r\n     * 이 함수를 호출하기전에 속성의 이름을 이 감시자가 가지고 있는 값으로 변경해야 한다.\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_Valueless(domPushData) {\r\n        this._Dom.push({\r\n            AxeViewDomType: 5 /* AxeViewDomType.Attr_Valueless */,\r\n            Dom: domPushData,\r\n            EventName: null\r\n        });\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - 혼자 값을 사용하는 경우\r\n     * 전체 데이터를 변경한다.\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_OneValue(domPushData) {\r\n        this._Dom.push({\r\n            AxeViewDomType: 6 /* AxeViewDomType.Attr_OneValue */,\r\n            Dom: domPushData,\r\n            EventName: null\r\n        });\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - 다른 값이 있어 리플레이스 하는 경우\r\n     * 감시자외의 다른값이 있다면 변환(리플레이스)로 처리해야 한다.\r\n     * 이때 같은 값이 있으면 오작동 할 수 있다.\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_ReplaceValue(domPushData) {\r\n        this._Dom.push({\r\n            AxeViewDomType: 7 /* AxeViewDomType.Attr_ReplaceValue */,\r\n            Dom: domPushData\r\n        });\r\n    }\r\n    /**\r\n     * 이벤트\r\n     * @param domPushData 이 이벤트를 가지고 있는 부모돔\r\n     * @param sEventName\r\n     * @param bPush dom리스트에 추가할지 여부\r\n     */\r\n    Dom_Push_Event(domPushData, sEventName, bPush) {\r\n        let objThis = this;\r\n        //이름 처리\r\n        if (4 /* OverwatchingOutputType.Function_NameRemoveOn */ === this.OverwatchingOutputType) { //이름 앞에 'on'을 뺀다.\r\n            if (2 <= sEventName.length) { //이름 길이가 충분하다\r\n                if (\"on\" === sEventName.substring(0, 2).toLowerCase()) { //앞에 두글자가 'on'이다.\r\n                    //2뒤에 글자만 추출\r\n                    sEventName = sEventName.substring(2);\r\n                }\r\n            }\r\n        }\r\n        //돔에 추가할 액스뷰 돔형식 생성\r\n        let avdTemp = {\r\n            AxeViewDomType: 8 /* AxeViewDomType.Attr_Event */,\r\n            Dom: domPushData,\r\n            EventName: sEventName\r\n        };\r\n        //이벤트로 사용할 함수\r\n        let funDom = function (event) {\r\n            objThis.data(event, avdTemp.Dom, objThis);\r\n        };\r\n        avdTemp.Event = funDom;\r\n        if (true === bPush) {\r\n            this._Dom.push(avdTemp);\r\n        }\r\n        //이벤트 리스너에 등록\r\n        avdTemp.Dom.removeEventListener(sEventName, avdTemp.Event);\r\n        avdTemp.Dom.addEventListener(sEventName, avdTemp.Event);\r\n    }\r\n    /**\r\n     * 연결된 돔 추가 - 값 모니터링 전용\r\n     * 이 경우 하나의 돔만 감시할 수 있으므로 맨처음 적중한 한개 만 추가되고 나머지는 무시된다.\r\n     * @param domPushData\r\n     */\r\n    Dom_Push_Attr_ValueMonitoring(domPushData) {\r\n        if (0 === this._Dom.length) {\r\n            let objThis = this;\r\n            //액스 돔으로 사용할 개체 만들기\r\n            let avdTemp = {\r\n                AxeViewDomType: 9 /* AxeViewDomType.Attr_ValueMonitoring */,\r\n                Dom: domPushData,\r\n                EventName: \"change\",\r\n                Event: function (event) {\r\n                    objThis.data = this.value;\r\n                }\r\n            };\r\n            //액스돔 리스트에 추가\r\n            objThis._Dom.push(avdTemp);\r\n            this.ValueMonitoringIs = true;\r\n            //체인지 이벤트 추가\r\n            avdTemp.Dom.removeEventListener(avdTemp.EventName, avdTemp.Event);\r\n            avdTemp.Dom.addEventListener(avdTemp.EventName, avdTemp.Event);\r\n        }\r\n    }\r\n    /** 연결된 돔 비우기 */\r\n    Dom_Clear() {\r\n        this._Dom = [];\r\n    }\r\n    /**\r\n     * 모니터링 중인 데이터 - 읽기\r\n     * Action을 읽어 리턴한다.\r\n     * UI가 갱신되지 않았다면 UI와 다른 값일 수 있다.\r\n     * */\r\n    get data() {\r\n        return this.DataNowGet();\r\n    }\r\n    /**\r\n     *  모니터링 중인 데이터 - 쓰기\r\n     *  Action에 데이터를 저장한다.\r\n     *  설정된 'OverwatchingType'에 따라 화면 갱신이 있을 수 있다.\r\n     */\r\n    set data(value) {\r\n        this.DataNowSet(value);\r\n    }\r\n    /** 지금 가지고 있는 데이터를 다시 출력시도한다.\r\n     * dom이 새로 설정됐다면 꼭 호출해야 한다.*/\r\n    DataRefresh() {\r\n        this.data = this.data;\r\n    }\r\n    constructor(target) {\r\n        /**\r\n         *  액스뷰에서 지정한 고유번호.\r\n         *  액스뷰를 바인딩할때 자동으로 입력된다.\r\n         *  이 값이 중복되면 교체(Replace)가 잘 안될 수 있다.\r\n         * */\r\n        this.MyNumber = 0;\r\n        /**\r\n         * 찾을 이름\r\n         * OverwatchInterface.Name 참조\r\n         * */\r\n        this.Name = \"\";\r\n        /** 이름 검색용 문자열\r\n         * 자동생성된다.*/\r\n        this.NameFindString = \"\";\r\n        /** 지금 가지고 있는 데이터 */\r\n        this.DataNow = \"\";\r\n        /**\r\n         *  지금 가지고 있는 데이터 - Replace\r\n         *  교체(Replace)의 경우 이전값이 빈값이면 동작할 수 없으므로\r\n         *  임의의 고유값을 생성하여 저장하는 변수다.\r\n         * */\r\n        this.DataNow_ReplaceValue = \"\";\r\n        /**\r\n         * 실제 동작 get\r\n         */\r\n        this.DataNowGet = () => {\r\n            let sReturn = \"\";\r\n            if (true === this.DomIs) { //돔 개체 전용\r\n                sReturn = this.DataNow;\r\n            }\r\n            else if (true === this.ValueMonitoringIs) { //값 모니터링 전용\r\n                if (0 < this._Dom.length) {\r\n                    //값 모니터링은 돔의 value를 우선한다.\r\n                    sReturn = this._Dom[0].Dom.value;\r\n                }\r\n            }\r\n            else {\r\n                sReturn = this.DataNow;\r\n            }\r\n            return sReturn;\r\n        };\r\n        /**\r\n         * 실제 동작 set\r\n         * @param data\r\n         */\r\n        this.DataNowSet = function (data) {\r\n            //기존값 백업\r\n            let OldData = this.DataNow;\r\n            let OldReplaceValue = this.DataNow_ReplaceValue;\r\n            //새값 저장\r\n            this.DataNow = data;\r\n            if (null !== this._Dom\r\n                && 0 < this._Dom.length) { //돔이 있으면 실행\r\n                //저장된 돔개수만큼 실행\r\n                for (let nDomIdx = 0; nDomIdx < this._Dom.length; ++nDomIdx) {\r\n                    let item = this.Dom[nDomIdx];\r\n                    //item.innerHTML = this.DataNow;\r\n                    if (3 /* AxeViewDomType.Node */ === item.AxeViewDomType) {\r\n                        item.Dom.nodeValue = this.DataNow;\r\n                    }\r\n                    else if (4 /* AxeViewDomType.Dom */ === item.AxeViewDomType) { //돔인 경우\r\n                        //돔은 교체만 허용한다.\r\n                        if (true === (this.DataNow instanceof HTMLElement)) { //들어온 값이 HTMLElement다.\r\n                            //돔의 경우 이전 개체(OldData)의 부모를 찾아\r\n                            //.replaceChild를 해야 한다.\r\n                            OldData.parentElement\r\n                                .replaceChild(this.DataNow, OldData);\r\n                        }\r\n                    }\r\n                    else if (6 /* AxeViewDomType.Attr_OneValue */ === item.AxeViewDomType\r\n                        || 9 /* AxeViewDomType.Attr_ValueMonitoring */ === item.AxeViewDomType) {\r\n                        item.Dom.value = this.DataNow;\r\n                    }\r\n                    else if (7 /* AxeViewDomType.Attr_ReplaceValue */ === item.AxeViewDomType) {\r\n                        let attrTemp = item.Dom;\r\n                        //벨류의 경우 대소문자 구분이 가능하므로 소문자 변환을 하면 안된다.\r\n                        //속성을 교체하는 방식인 경우 빈값이 들어오면 교체하지 못하므로\r\n                        //임의의 고유값을 생성하여 저장한다.\r\n                        //이전 데이터를 백업하고\r\n                        let OldDataTemp = OldReplaceValue;\r\n                        if (\"\" === OldDataTemp) {\r\n                            OldDataTemp = OldData;\r\n                        }\r\n                        //현재 데이터 저장\r\n                        this.DataNow_ReplaceValue = this.DataNow;\r\n                        if (\"\" === this.DataNow_ReplaceValue) { //현재 데이터가 비어있다.\r\n                            //임의의 값을 생성해 준다.\r\n                            this.DataNow_ReplaceValue\r\n                                = OldData + \"_AxeViewTemp\" + this.MyNumber;\r\n                        }\r\n                        if (true === this.OverwatchingOneIs) { //한개만 교체\r\n                            attrTemp.value\r\n                                = attrTemp.value.replace(OldDataTemp, this.DataNow_ReplaceValue);\r\n                        }\r\n                        else { //전체 교체\r\n                            attrTemp.value\r\n                                = this.ReplaceAll(attrTemp.value, OldDataTemp, this.DataNow_ReplaceValue);\r\n                        }\r\n                    }\r\n                    else if (5 /* AxeViewDomType.Attr_Valueless */ === item.AxeViewDomType) {\r\n                        //값이 없는 값은 속성자체를 바꿔야 한다.\r\n                        let elemTemp = item.Dom;\r\n                        //기존 이름 제거\r\n                        elemTemp.removeAttribute(OldData.toLowerCase());\r\n                        //새 이름 추가(값없음)\r\n                        elemTemp.setAttribute(this.DataNow, \"\");\r\n                    }\r\n                    else if (8 /* AxeViewDomType.Attr_Event */ === item.AxeViewDomType) {\r\n                        //기존에 연결된 이벤트 제거\r\n                        item.Dom.removeEventListener(item.EventName, item.Event);\r\n                        //새로들어온 이벤트 연결\r\n                        item.Event = data;\r\n                        item.Dom.addEventListener(item.EventName, item.Event);\r\n                    }\r\n                    else {\r\n                        if (true === (data instanceof Element)\r\n                            || true === (data instanceof HTMLElement)\r\n                            //|| true === (data instanceof ChildNode)\r\n                            || true === (data instanceof Node)) {\r\n                            item.Dom.innerHTML = \"\";\r\n                            item.Dom\r\n                                .insertAdjacentElement(\"beforeend\", data);\r\n                        }\r\n                        else {\r\n                            item.Dom.innerHTML = data;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * 한개만 감시할지 여부\r\n         * OverwatchInterface.OverwatchingOneIs 참고\r\n         */\r\n        this.OverwatchingOneIs = false;\r\n        /**\r\n         * 연결되있는 돔\r\n         * 단순 출력의 경우 추가하지 않는다.\r\n         * 여러개가 연결된 경우 각각의 돔이들어있게 된다.\r\n         * 'Action'이 어트리뷰트에 연결된 경우 대상 dom이 저장되고,\r\n         * innerText영역에 있는 경우 임의로 생성된 태그가 지정된다.\r\n         *\r\n         * Dom 개체 형식의 경우 부모는 무조건 한개가 되므로 이 배열에 추가하지 않는다.\r\n         * (DataNow만 사용)\r\n         * */\r\n        this._Dom = [];\r\n        /** 'OverwatchingType'가 한번만 적중해야 하는 옵션인경우\r\n         * 맨처음 적중하면 true가 된다.*/\r\n        this.OneDataIs = false;\r\n        /** 값 모니터링 전용인지 여부 */\r\n        this.ValueMonitoringIs = false;\r\n        /** 돔 개체 전용인지 여부 */\r\n        this.DomIs = false;\r\n        this.Name = target.Name;\r\n        this.NameFindString = \"{{\" + this.Name + \"}}\";\r\n        if (\"\" === target.FirstData\r\n            || \" \" === target.FirstData) {\r\n            if (1 /* OverwatchingOutputType.String */ === this.OverwatchingOutputType) {\r\n                //이 값은 절대 비어있으면 안된다.(빈값을 쓰려면 스페이스를 사용하자)\r\n                //빈값으로는 노드를 생성하지 않고 있기 때문이다.\r\n                this.DataNow = \" \";\r\n            }\r\n            else if (2 /* OverwatchingOutputType.Html */ === this.OverwatchingOutputType) {\r\n                //데이터가 html인경우 빈값을 넣으면 안되고 보이지 않는 요소라라도 하나 넣어야 한다.\r\n                //(<div></div>)\r\n                //안그러면 text 노드가 생성되서 에러가 난다.\r\n                //그래서 여기서 넣어준다.\r\n                this.DataNow = \"<div></div>\";\r\n            }\r\n        }\r\n        else {\r\n            this.DataNow = target.FirstData;\r\n        }\r\n        this.OverwatchingOutputType = target.OverwatchingOutputType;\r\n        this.OverwatchingType = target.OverwatchingType;\r\n        this.OverwatchingOneIs = target.OverwatchingOneIs;\r\n    }\r\n    /**\r\n     * 지정한 문자열을 모두 찾아 변환한다.\r\n     * @param sOriData 원본\r\n     * @param sSearch 찾을 문자열\r\n     * @param sReplacement 바꿀 문자열\r\n     * @returns 완성된 결과\r\n     */\r\n    ReplaceAll(sOriData, sSearch, sReplacement) {\r\n        return sOriData.replace(new RegExp(sSearch, 'g'), sReplacement);\r\n    }\r\n}\r\nexports.Overwatch = Overwatch;\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/Overwatch.ts?");

/***/ }),

/***/ "./src/AxeView/OverwatchInterface.ts":
/*!*******************************************!*\
  !*** ./src/AxeView/OverwatchInterface.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/OverwatchInterface.ts?");

/***/ }),

/***/ "./src/AxeView/OverwatchingType.ts":
/*!*****************************************!*\
  !*** ./src/AxeView/OverwatchingType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://axe-view/./src/AxeView/OverwatchingType.ts?");

/***/ }),

/***/ "./src/Example/test_01.ts":
/*!********************************!*\
  !*** ./src/Example/test_01.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst AxeView_1 = __webpack_require__(/*! ../AxeView/AxeView */ \"./src/AxeView/AxeView.ts\");\r\nclass test_01 {\r\n    constructor() {\r\n        /** 액스뷰 개체 */\r\n        this.AxeView = new AxeView_1.default();\r\n        /** AxeView 테스트용 변수 */\r\n        this.arrTarget = [];\r\n        /** 돔개체 테스트용 */\r\n        this.domNew = document.createElement(\"div\");\r\n        this.TestCilck = () => {\r\n            this.TextInput();\r\n            let findTarget = document.querySelector(\"#divAxeViewTset > div\");\r\n            let findParent = document.querySelector(\"#divAxeViewTset\");\r\n            findParent.replaceChild(this.domNew, findTarget);\r\n        };\r\n        this.TestCilck2 = () => {\r\n            this.TextInput();\r\n            this.arrTarget[0].data = this.domNew;\r\n        };\r\n        this.TextInput = () => {\r\n            let sTnput = document.getElementById(\"txtInput\").value;\r\n            this.domNew.innerHTML = \"<h5>\" + sTnput + \"</h5>\";\r\n        };\r\n        //주석 제거\r\n        this.AxeView.CommentDelete = false;\r\n        this.domNew.innerHTML = \"<h5>추가됐습니다.</h5>\";\r\n        this.arrTarget.push(\r\n        //돔 찾기\r\n        new AxeView_1.Overwatch({\r\n            Name: \"HtmlDom\",\r\n            FirstData: this.domNew,\r\n            OverwatchingOutputType: 5 /* OverwatchingOutputType.Dom */,\r\n            OverwatchingType: 0 /* OverwatchingType.OutputFirst */,\r\n            OverwatchingOneIs: true\r\n        }));\r\n        //돔 재생성 및 설정된 뷰모델 연결\r\n        this.AxeView.BindOverwatch(document.getElementById(\"divAxeViewTset\"), this.arrTarget);\r\n        document.getElementById(\"btnClick\").onclick = this.TestCilck;\r\n        document.getElementById(\"btnClick2\").onclick = this.TestCilck2;\r\n    }\r\n}\r\nexports[\"default\"] = test_01;\r\n\n\n//# sourceURL=webpack://axe-view/./src/Example/test_01.ts?");

/***/ }),

/***/ "./src/Example/test_BasicSample.ts":
/*!*****************************************!*\
  !*** ./src/Example/test_BasicSample.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst AxeView_1 = __webpack_require__(/*! ../AxeView/AxeView */ \"./src/AxeView/AxeView.ts\");\r\nclass testBasicSample {\r\n    constructor() {\r\n        /** 액스뷰 개체 */\r\n        this.AxeView = new AxeView_1.default();\r\n        //AxeView 테스트용 변수\r\n        this.arrTarget = [];\r\n        this.TestCilck = () => {\r\n            debugger;\r\n            this.arrTarget[2].data = \"클릭했다!!!\";\r\n            this.arrTarget[3].data = \"<h2>클릭했다!!HTML</h2>\";\r\n            this.arrTarget[4].data = \"Click1\";\r\n            this.arrTarget[5].data = \"Check2\";\r\n            this.arrTarget[6].data = function (sender, event, objThis) {\r\n                alert(\"재바인딩됨\");\r\n                console.log(sender);\r\n                console.log(event);\r\n                console.log(objThis);\r\n            };\r\n            this.arrTarget[7].data = \"\";\r\n            let sTemp1 = document.getElementById(\"divTemp1\").getAttribute(\"axeTest2\");\r\n            document.getElementById(\"divTemp1\").setAttribute(\"axeTest2\", sTemp1 + \" AddTest\");\r\n            this.arrTarget[8].data = \"Click4\";\r\n            console.log(\"클릭함 : \" + this.arrTarget[9].data);\r\n            //this.arrTarget[9].data = \"asdfasdfd11\";\r\n        };\r\n        this.TestCilck2 = () => {\r\n            this.arrTarget[7].data = \"ReClick\";\r\n        };\r\n        //주석 제거\r\n        this.AxeView.CommentDelete = true;\r\n        //액스뷰 테스트****\r\n        this.arrTarget.push(\r\n        //단순 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"StringTest\",\r\n            FirstData: \"문자열 출력!!\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 0 /* OverwatchingType.OutputFirst */,\r\n            OverwatchingOneIs: true\r\n        }));\r\n        this.arrTarget.push(\r\n        //단순 html 출력\r\n        new AxeView_1.Overwatch({\r\n            Name: \"HtmlTest\",\r\n            FirstData: \"<h3>Html 출력!</h3>\",\r\n            OverwatchingOutputType: 2 /* OverwatchingOutputType.Html */,\r\n            OverwatchingType: 0 /* OverwatchingType.OutputFirst */,\r\n            OverwatchingOneIs: true\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringString\",\r\n            FirstData: \"모니터링중(문자열)\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringHtml\",\r\n            FirstData: \"<h1>모니터링중(Html)</h1>\",\r\n            OverwatchingOutputType: 2 /* OverwatchingOutputType.Html */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr1\",\r\n            FirstData: \"attrTest1\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr2\",\r\n            FirstData: \"attrTest2\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"FunctionTest\",\r\n            FirstData: function (event, sender, objThis) {\r\n                alert(\"바인딩됨\");\r\n                console.log(sender);\r\n                console.log(event);\r\n                console.log(objThis);\r\n                debugger;\r\n            },\r\n            OverwatchingOutputType: 4 /* OverwatchingOutputType.Function_NameRemoveOn */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"CssTest\",\r\n            FirstData: \"CssAdd\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr3\",\r\n            FirstData: \"attrTest3\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr4\",\r\n            FirstData: \"attrTest4\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 3 /* OverwatchingType.Monitoring_AttrValue */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        //돔 재생성 및 설정된 뷰모델 연결\r\n        this.AxeView.BindOverwatch(document.getElementById(\"divAxeViewTset\"), this.arrTarget);\r\n        //돔 추가 처리\r\n        this.AxeView.DomHelper(document.getElementById(\"divAxeViewTset\"), {\r\n            OptionUse: true,\r\n            AtagClickEventCancel: true,\r\n            AtagClickEventCallback: function (event) {\r\n                console.log(\"A tag click : \" + event.target.pathname);\r\n            }\r\n        });\r\n        document.getElementById(\"btnClick\").onclick = this.TestCilck;\r\n        document.getElementById(\"btnClick2\").onclick = this.TestCilck2;\r\n    }\r\n}\r\nexports[\"default\"] = testBasicSample;\r\n\n\n//# sourceURL=webpack://axe-view/./src/Example/test_BasicSample.ts?");

/***/ }),

/***/ "./src/Example/test_StartUp.ts":
/*!*************************************!*\
  !*** ./src/Example/test_StartUp.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst AxeView_1 = __webpack_require__(/*! ../AxeView/AxeView */ \"./src/AxeView/AxeView.ts\");\r\nclass test_StartUp {\r\n    constructor() {\r\n        /** 액스뷰 개체 */\r\n        this.AxeView = new AxeView_1.default();\r\n        //AxeView 테스트용 변수\r\n        this.arrTarget = [];\r\n        this.TestCilck = () => {\r\n            debugger;\r\n            this.arrTarget[2].data = \"클릭했다!!!\";\r\n            this.arrTarget[3].data = \"<h2>클릭했다!!HTML</h2>\";\r\n            this.arrTarget[4].data = \"Click1\";\r\n            this.arrTarget[5].data = \"Check2\";\r\n            this.arrTarget[6].data = function (sender, event, objThis) {\r\n                alert(\"재바인딩됨\");\r\n                console.log(sender);\r\n                console.log(event);\r\n                console.log(objThis);\r\n            };\r\n            this.arrTarget[7].data = \"\";\r\n            let sTemp1 = document.getElementById(\"divTemp1\").getAttribute(\"axeTest2\");\r\n            document.getElementById(\"divTemp1\").setAttribute(\"axeTest2\", sTemp1 + \" AddTest\");\r\n            this.arrTarget[8].data = \"Click4\";\r\n            console.log(\"클릭함 : \" + this.arrTarget[9].data);\r\n            //this.arrTarget[9].data = \"asdfasdfd11\";\r\n        };\r\n        this.TestCilck2 = () => {\r\n            this.arrTarget[7].data = \"ReClick\";\r\n        };\r\n        //주석 제거\r\n        this.AxeView.CommentDelete = true;\r\n        //액스뷰 테스트****\r\n        this.arrTarget.push(\r\n        //단순 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"StringTest\",\r\n            FirstData: \"문자열 출력!!\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 0 /* OverwatchingType.OutputFirst */,\r\n            OverwatchingOneIs: true\r\n        }));\r\n        this.arrTarget.push(\r\n        //단순 html 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"HtmlTest\",\r\n            FirstData: \"<h3>Html 출력!</h3>\",\r\n            OverwatchingOutputType: 2 /* OverwatchingOutputType.Html */,\r\n            OverwatchingType: 0 /* OverwatchingType.OutputFirst */,\r\n            OverwatchingOneIs: true\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringString\",\r\n            FirstData: \"모니터링중(문자열)\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringHtml\",\r\n            FirstData: \"<h1>모니터링중(Html)</h1>\",\r\n            OverwatchingOutputType: 2 /* OverwatchingOutputType.Html */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr1\",\r\n            FirstData: \"attrTest1\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr2\",\r\n            FirstData: \"attrTest2\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"FunctionTest\",\r\n            FirstData: function (event, sender, objThis) {\r\n                alert(\"바인딩됨\");\r\n                console.log(sender);\r\n                console.log(event);\r\n                console.log(objThis);\r\n                debugger;\r\n            },\r\n            OverwatchingOutputType: 4 /* OverwatchingOutputType.Function_NameRemoveOn */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"CssTest\",\r\n            FirstData: \"CssAdd\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr3\",\r\n            FirstData: \"attrTest3\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 1 /* OverwatchingType.Monitoring */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        this.arrTarget.push(\r\n        //모니터링 문자열 검색\r\n        new AxeView_1.Overwatch({\r\n            Name: \"MonitoringAttr4\",\r\n            FirstData: \"attrTest4\",\r\n            OverwatchingOutputType: 1 /* OverwatchingOutputType.String */,\r\n            OverwatchingType: 3 /* OverwatchingType.Monitoring_AttrValue */,\r\n            OverwatchingOneIs: false\r\n        }));\r\n        //돔 재생성 및 설정된 뷰모델 연결\r\n        this.AxeView.BindOverwatch(document.getElementById(\"divAxeViewTset\"), this.arrTarget);\r\n        //돔 추가 처리\r\n        this.AxeView.DomHelper(document.getElementById(\"divAxeViewTset\"), {\r\n            OptionUse: true,\r\n            AtagClickEventCancel: true,\r\n            AtagClickEventCallback: function (event) {\r\n                console.log(\"A tag click : \" + event.target.pathname);\r\n            }\r\n        });\r\n        document.getElementById(\"btnClick\").onclick = this.TestCilck;\r\n        document.getElementById(\"btnClick2\").onclick = this.TestCilck2;\r\n    }\r\n}\r\nexports[\"default\"] = test_StartUp;\r\n\n\n//# sourceURL=webpack://axe-view/./src/Example/test_StartUp.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst test_StartUp_1 = __webpack_require__(/*! ./Example/test_StartUp */ \"./src/Example/test_StartUp.ts\");\r\nconst test_BasicSample_1 = __webpack_require__(/*! ./Example/test_BasicSample */ \"./src/Example/test_BasicSample.ts\");\r\nconst test_01_1 = __webpack_require__(/*! ./Example/test_01 */ \"./src/Example/test_01.ts\");\r\nclass App {\r\n    constructor() {\r\n        //지금 보여주고 있는 페이지에서 사용할 개체\r\n        this.PageNow = null;\r\n        //파일명으로 라우터 처럼 동작하게 해준다.\r\n        let arrPath = window.location.pathname.split(\"/\");\r\n        switch (arrPath[arrPath.length - 1]) {\r\n            case \"index.html\":\r\n                break;\r\n            case \"test_StartUp.html\":\r\n                this.PageNow = new test_StartUp_1.default();\r\n                break;\r\n            case \"test_BasicSample.html\":\r\n                this.PageNow = new test_BasicSample_1.default();\r\n                break;\r\n            case \"test_01.html\":\r\n                this.PageNow = new test_01_1.default();\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports[\"default\"] = App;\r\nwindow.app = new App();\r\n\n\n//# sourceURL=webpack://axe-view/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;